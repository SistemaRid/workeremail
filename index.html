<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <title>Worker RID</title>

  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/emailjs-com@3/dist/email.min.js"></script>
</head>
<body>

<h2>Worker de E-mails RID</h2>
<p>Status: <span id="status">iniciando‚Ä¶</span></p>

<script>
    emailjs.init("2AYL-lDTSgF5yPjHB");
    console.log("üî• SCRIPT DO WORKER CARREGOU");
const firebaseConfig = {
  apiKey: "AIzaSyDAcuwo5FZBs5013klfSMfWkQZbFjqYpbw",
  authDomain: "novo-rid-dezembro.firebaseapp.com",
  projectId: "novo-rid-dezembro"
};

  firebase.initializeApp(firebaseConfig);

  const db = firebase.firestore();
  const statusEl = document.getElementById("status");

  statusEl.innerText = "worker inicializado";

  // executa imediatamente
  runWorker();

  // executa novamente a cada 1 minuto
  setInterval(runWorker, 60000);

 async function runWorker() {
  console.log("üîÅ Worker executando (modo normal)");

  const lockRef = db.doc("system/emailWorkerLock");

  const locked = await db.runTransaction(async (tx) => {
    const snap = await tx.get(lockRef);

    if (snap.exists && snap.data().locked === true) {
  const last = snap.data().at?.toMillis?.() || 0;

  // ‚è±Ô∏è lock mais velho que 5 minutos ‚Üí libera
  if (Date.now() - last > 5 * 60 * 1000) {
    console.warn("‚ö†Ô∏è Lock antigo detectado, for√ßando libera√ß√£o");
  } else {
    return false;
  }
}


    tx.set(lockRef, {
      locked: true,
      at: firebase.firestore.FieldValue.serverTimestamp()
    });

    return true;
  });

  if (!locked) {
    console.log("‚è∏Ô∏è Worker j√° est√° em execu√ß√£o");
    return;
  }

    try {
      const snapshot = await db
  .collection("rids")
  .where("status", "==", "aberto")
  .orderBy("createdAt")
  .limit(1)
  .get();

if (snapshot.empty) {
  console.log("üì≠ Nenhuma RID pendente");
  return;
}



// üîí pega somente a PRIMEIRA RID
const doc = snapshot.docs[0];
const rid = doc.data();


// üîí fallback de e-mail (2 destinat√°rios)
let toEmail = "sistemarids@gmail.com, cesar.costa@jdemito.com.br";

let shouldNotify = false;

// üìå NOVA RID (COM OU SEM L√çDER)
if (!rid.lastNotifiedLeader) {
  shouldNotify = true;
}

// üîÅ TROCA DE L√çDER
if (
  rid.lastNotifiedLeader &&
  rid.responsibleLeader &&
  rid.lastNotifiedLeader !== rid.responsibleLeader
) {
  shouldNotify = true;
}

if (!shouldNotify) {
  console.log("‚Ñπ Nenhuma notifica√ß√£o necess√°ria:", rid.ridNumber);
  return;
}

// üîé SE TIVER L√çDER, tenta buscar e-mail
if (rid.responsibleLeader) {
  const leaderSnap = await db
    .collection("leaders_public")
    .doc(rid.responsibleLeader)
    .get();

  if (leaderSnap.exists && leaderSnap.data().email) {
    toEmail = leaderSnap.data().email;
  } else {
    console.log("‚ö†Ô∏è L√≠der sem e-mail p√∫blico, usando fallback");
  }
} else {
  console.log("‚ÑπÔ∏è RID sem l√≠der, usando fallback");
}


console.log(" Enviando e-mail da RID:", rid.ridNumber, "para", toEmail);

await emailjs.send(
  "service_mfu6oes",
  "template_47puito",
  {
    ridNumber: rid.ridNumber,
    emitterName: rid.emitterName || "N√£o informado",
    sector: rid.sector,
    riskClassification: rid.riskClassification,
    status: rid.status,
    description: rid.description,
    to_email: toEmail
  }
);

if (rid.responsibleLeader) {
  await db.collection("rids").doc(doc.id).update({
    lastNotifiedLeader: rid.responsibleLeader
  });
}

console.log(" E-mail enviado:", rid.ridNumber);

  } finally {
  await db.doc("system/emailWorkerLock").set({
  locked: false,
  releasedAt: firebase.firestore.FieldValue.serverTimestamp()
}, { merge: true });
}
 }


</script>

</body>
</html>
